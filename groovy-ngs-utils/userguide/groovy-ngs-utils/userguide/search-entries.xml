<znai>
  <entry>
    <url>/groovy-ngs-utils/userguide</url>
    <fullTitle>Groovy NGS Groovy NGS</fullTitle>
    <text>
      <text>A toolkit for working with genomic sequencing data in Groovy.The JVM is a powerful platform for data analysis, offering high performance, strong library and platform support with excellent deployment options when it comes time to scale up and productionise your work. Groovy NGS aims to unlock the power of the JVM for working with genomic sequencing data by enabling it to be used with the versatile and highly productive Groovy programming language.Groovy NGS can be used at three levels:Directly as pre-written tools on the command line For writing simple scripts (bash-style) or interactive analysis in https://github.com/ssadedin/beakerx Jupyter Notebooks As a library of classes for building full-scale applications Under the hood, Groovy NGS is built on the widely used https://github.com/samtools/htsjdk HTSJDK. However Groovy NGS makes it much easier to work with these libraries by adding idiomatic Groovy language constructs and filling in important commonly used missing features.Examples of supported functionality are:Reading, processing and filtering VCF files, including integration with common annotation sources such as VEP Working with Genomic Ranges - full set of operation as well as higher level reading, processing and filtering Reading, processing and performing logical operations with pedigree (PED) files and family structures Working with BAM/SAM/CRAM files (including, generating and working with Pileups) A range of statistical operations including R-like data frames and linear modeling constructs Many many more useful operations</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/introduction#what-is-groovy-ngs</url>
    <fullTitle>Groovy NGS: Introduction, What is Groovy NGS? [Chapter One]</fullTitle>
    <text>
      <text>Welcome to Groovy NGS!Groovy NGS tries to unlock the power of the JVM as a scripting and rapid application development platform for analysis of genomic sequencing data (particularly, NGS data). It does this by building on the popular https://github.com/samtools/htsjdk HTSJDK library to make its functionality greatly more accessible - primarily, by exposing it in an idiomatic way in the Groovy JVM language.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/introduction#why-groovy</url>
    <fullTitle>Groovy NGS: Introduction, Why Groovy? [Chapter One]</fullTitle>
    <text>
      <text>Groovy is a dynamic programming language that is widely used for scripting, domain specific languages (such as https://bpipe.org Bpipe and https://nextflow.io Nextflow) as well as full applications. It brings a unique blend of high performance and dynamic features that are ideal for rapid application development and interactive analysis. In many ways, Groovy is similar to Python from a language point of view, but without the downsides of Python such as slow performance and parallelisation capabilities, and with seamless integration into the enormous Java library ecosystem.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/introduction#structure</url>
    <fullTitle>Groovy NGS: Introduction, Structure [Chapter One]</fullTitle>
    <text>
      <text>This guide first presents some conceptual and foundational topics and then is split into sections based on the broad types categories of functionalities that are available.Chapter 1: Key foundations - installing, running and writing simple scripts Chapter 2: Working with Genomic Regions Chapter 3: Working with VCFs Chapter 4: Working with alignment files (BAM, CRAM) Chapter 5: Miscellaneous Utilities</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/introduction#api-documentation</url>
    <fullTitle>Groovy NGS: Introduction, API Documentation [Chapter One]</fullTitle>
    <text>
      <text>This guide is designed to give you a user friendly introduction to Groovy NGS with plenty of examples and explanations. There are, however, many more details that are not contained here. To fully understand usage of the classes as well as important limitations, reference the https://ssadedin.github.io/groovy-ngs-utils/doc/ API documentation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/how-to-use-groovy-NGS#as-a-dependency-in-projects</url>
    <fullTitle>Groovy NGS: How To Use Groovy NGS, As a Dependency In Projects [Chapter One]</fullTitle>
    <text>
      <text>The default way to use Groovy NGS is to build a "fat" jar and include it in your project. This jar file can be created by cloning the repository and executing the gradle command to build the jar: git clone --recursive https://github.com/ssadedin/groovy-ngs-utils.git ./gradlew jar The jar file is created in build/libs/groovy-ngs-utils.jar and includes all necessary dependencies except for Groovy itself. Therefore, you should include the https://mvnrepository.com/artifact/org.apache.groovy/groovy-all groovy-all dependency from Maven for the appropriate Groovy version in your project as well.Note: in the future it is expected that Groovy NGS will move to support Maven repository based dependency resolution so that it can be more easily included in other projects.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/how-to-use-groovy-NGS#on-the-command-line</url>
    <fullTitle>Groovy NGS: How To Use Groovy NGS, On the Command Line [Chapter One]</fullTitle>
    <text>
      <text>Another way to use Groovy NGS is to use the gngs command to execute expressions directly on the command line. For example, after building (as above), to filter a VCF to only chromosome 21: bash cat test.vcf | ./bin/gngs 'VCF.filter { it.chr == "chr21" }' > test.chr21.vcf</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/how-to-use-groovy-NGS#interactively-via-a-groovy-shell</url>
    <fullTitle>Groovy NGS: How To Use Groovy NGS, Interactively via a Groovy Shell [Chapter One]</fullTitle>
    <text>
      <text>You can run Groovy NGS as a https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop REPL to run commands interactively and see the results using the standard Groovy Shell. To facilitate this, there is a script in the bin folder to launch the Groovy Shell with Groovy NGS added to the classpath and the gngs package automatically imported. This can be a very useful way to experiment and learn about how Groovy NGS and Groovy itself works.Here is how an example session looks: bash ./bin/gngsh Groovy Shell (3.0.10, JVM: 11.0.18) Type ':help' or ':h' for help. ------------------------------------------------------------------------------------------------------ groovy:000> import gngs.*; ===> gngs.* groovy:000> vcf = VCF.parse('src/test/data/giab1.tiny.trio.vcf') ===> VCF file src/test/data/giab1.tiny.trio.vcf for NA12877,NA12878,NA12879 groovy:000> vcf.size() ===> 24 groovy:000> vcf.count { it.het } ===> 20</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-one/how-to-use-groovy-NGS#in-a-jupyter-notebook</url>
    <fullTitle>Groovy NGS: How To Use Groovy NGS, In a Jupyter Notebook [Chapter One]</fullTitle>
    <text>
      <text>A final way to use Groovy NGS is via Jupyter. You can use any available Groovy kernel, however a particularly useful one is https://github.com/twosigma/beakerx BeakerX which provides Groovy kernels out of the box along with a range of Jupyter widgets as enhancements. Together with Groovy NGS. this makes a very effective data analysis platform for genomic data.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/regions-and-ranges#regions-and-ranges</url>
    <fullTitle>Groovy NGS: Regions And Ranges, Regions and Ranges [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>DNA is most commonly conceptualised as a set chromosomes or contigs represented by linear coordinate systems. Defining and manipulating spans within these spaces is therefore been critical to working with genomic data. Entities such as genes, exons, transcripts, variants, and many similar constructs are usually represented as coordinates within the genome, typically referred to as spans, ranges or regions. This section explains how to work with genomic regions in Groovy-NGS.Groovy itself provides interfaces and a small amount of native support for working with ranges of values, such as the https://docs.groovy-lang.org/latest/html/api/groovy/lang/Range.htm Range class. Unfortunately this support is very minimal, so Groovy-NGS builds on these to provide full featured range operation support. In general, the terminology is used as follows: Terminology Range : A contiguous sequence of genomic positions not qualfied by a contig / chromosome (defined by start and end position) Region : A range that is further associated with a specific sequence, ie: a chromosome, or contig. Operations treat Regions associated with different sequences as independent entities that do not interact. Note: for historical reasons, Groovy-NGS uses chr to refer to the contig or chromosome with which a Region is associated. For all intents and purposes, you may think of the chr as a contig, or even an abstract sequence name. Key Supporting Classes Formally, the key classes supporting range operations in Groovy-NGS are: Type Description [IRegion](https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/IRegion.html) Core interface implemented by all data types that can interface with range operations - supports only contig and interval. Data types representing entities that are localisable to a specific position in the genome usually implement `IRegion` to specify their location. [Region](https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Region.html) A region implementation that is also a groovy [expando](https://docs.groovy-lang.org/latest/html/api/groovy/util/Expando.html). This means that you can set your own properties directly on this object, allowing convenient association of meta data or ancilliary information to the region in data analysis. [Regions](https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Regions.html) A collection of potentially overlapping `Region` objects, stored in indexed fashion for rapid lookup. Implementation Under the hood, Groovy-NGS stores each range in a Regions object using an index that enables efficient lookup. Unlike the commonly used approach of applying an https://en.wikipedia.org/wiki/Interval_tree Interval Tree, Groovy-NGS uses a boundary index. That is, when a new range is inserted, the two end points are inserted into a tree map ordered on position, specific to the chromosome / contig. At places where the range overlaps existing ranges already in the index, breakpoint entries are inserted. In this way, every boundary is represented in the index, enabling O(1) lookup of which entries overlap a given position. This functionality is supported by the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/RangeIndex.html RangeIndex class.Note: the breakpoint index design allows for extremely rapid local lookup, but creates some worst case performance outcomes you may wish to look out for. In particular, the scenario where many small regions are inserted first and then a set of large regions are inserted after causes the insertion operation to become O(N) on the number of small regions. Now that HTSJDK offers a native https://samtools.github.io/htsjdk/javadoc/htsjdk/htsjdk/samtools/util/IntervalTree.html IntervalTree an implementation backed by this class may be considered to allow this worst case to be avoided. If you encounter the worst case described here, using the HTSJDK IntervalTree class instead may be an option.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/common-operations#creating-regions-objects</url>
    <fullTitle>Groovy NGS: Common Operations, Creating Regions Objects [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>This section describes how to do a variety of common operations that are useful in analysing genomic data.The first thing you need to do to work with regions is to create a https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Regions.html Regions object. One way to do this is "by hand" - ie: by manually constructing https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Region.html Region objects. You can do this by passing a region defined as a string using the standard format to the Region constructor, for example: groovy r = new Region('chr1:100-200') Then you can convert a list of these to a Regions object using the Groovy as operator. For example, consider the following set of regions: A |--------------------| B C D |---| |---| |---| 0 5 10 15 20 25 30 35 To create a Regions object representing these directly, we can use the following code: groovy regions = [ 'chr1:5-10', 'chr1:15-20', 'chr1:30-35', 'chr1:0-25' ].collect { new Region(it) } as Regions Observe that in this set of example regions we have overlapping ranges. In general, Groovy-NGS does not automatically combine or merge regions, and the resulting Regions object behaves much like a simple collection of the regions you put in, only with some operations accelerated. If you desire that the regions be combined, you need to use one of the specific operations to do that after creating your Regions object.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/common-operations#basic-metrics</url>
    <fullTitle>Groovy NGS: Common Operations, Basic Metrics [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>Some simple metrics you might like to know about your set of include: Description Code Output [{text=the total span of all the ranges included, type=SimpleText}] [{code=regions.size(), type=InlinedCode}] [{code=44, type=InlinedCode}] [{text=the count of the number of ranges included, type=SimpleText}] [{code=regions.numberOfRanges, type=InlinedCode}] [{code=4, type=InlinedCode}] Note: the use of size() slightly conflicts with the standard Groovy semantics for the size() method as this would normally return the number of elements in a collection. Instead, you can think of this as returning the total number of bases in the collection.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/common-operations#treating-as-a-collection</url>
    <fullTitle>Groovy NGS: Common Operations, Treating as a Collection [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>The Regions object implements standard Java and Groovy interfaces and methods to enable common collections operations. In particular, the https://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Iterable.html Iterable interface is implemented so that the full range of Groovy enhanced operations for collections are available. These operations are extremely powerful and often allow you to accomplish complex data analysis tasks with just a few lines of chained declarative invocations. When used as an Iterable , the Regions class will span across all chromosomes / contigs. If you want to operate at the chromosome/contig level, you can consider using the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Regions.html#index index attribute to access the per-chromosome index which also supports the Iterable interface. Indexed Access For accessing subsets of regions within a Regions object, specific support is provided to allow lookup using "square bracket" notation efficient. Therefore, for example, to access the 2nd and 3rd regions of our set, the following code will work:Input groovy regions[1..2] Output [chr1:15-20, chr1:30-35]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/common-operations#finding-overlaps</url>
    <fullTitle>Groovy NGS: Common Operations, Finding Overlaps [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>One of the most common needs is to find which regions overlap a given interval. Generally, the most practical method to use for this is the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Regions.html#getOverlapRegions(gngs.IRegion) getOverlapRegions method. This method will return a list of the regions from the set that have at least 1 base of overlap with the region that is specified.Example: to find which regions overlap the range 12 to 30:Input: groovy r = new Region('chr1:12-30') overlaps = regions.getOverlapRegions(r) Output: [chr1:0-25, chr1:15-20, chr1:30-35] Note: the getOverlapRegions method returns a List object rather than a Regions object. Therefore in this case, the .size() method returns the number of elements, not the total span of all the regions contains. In general, you will find Groovy NGS returns plain collections as a result of its methods, which you can then choose to convert into a Regions object by adding as Regions if that is what you need.Groovy NGS interprets region boundaries as inclusive. This means that the region chr1:0-10 includes the position 10 and does overlap the region chr1:10-20 .Note: There are several other getOverlaps methods. These can be slightly more efficient, in specific circumstances.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/common-operations#intersection</url>
    <fullTitle>Groovy NGS: Common Operations, Intersection [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>Intersection finds the shared parts of each region in your set with another region that you specify. To this, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Regions.html#intersectRegion(gngs.Region) intersectRegion method.Input groovy ix = regions.intersectRegion(r) ix*.toString() Output groovy [chr1:12-25, chr1:15-20, chr1:30-30]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/common-operations#flattening</url>
    <fullTitle>Groovy NGS: Common Operations, Flattening [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>In many types of analysis, you desire to know only the total set of regions encompassed by an overlapping set. Groovy-NGS mirrors the R-lang terminology here, offering a reduce function to flatten a set of regions to an equivalent set where all overlaps are compressed to a single region.Input groovy regions.reduce()*.toString() Output [chr1:0-25, chr1:30-35] This has changed the ranges to the following: |--------------------| |---| 0 5 10 15 20 25 30 35</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/common-operations#assigning-properties</url>
    <fullTitle>Groovy NGS: Common Operations, Assigning Properties [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>In analysing genomic data we usually are interested in specific attributes of the regions we are working with. For example, the genes they represent, statistics about their attributes or any arbitrary data that we associate with the region for the purpose of the analysis. It is very convenient therefore to be able to attach metadata to each region so that these are available at any point they are needed in analysis.The Groovy-NGS https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Region.html Region class extends the Groovy https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Region.html Expando class which allows you to set arbitrary properties on the object alongside the properties that the class natively supports. For example:Input groovy regions[0].foo = 'bar' regions[1].foo = 'baz' regions[2].foo = 'boo' regions[3].foo = 'boz' regions.each { r -> println "The region $r has foo = $r.foo" } Output The region chr1:5-10 has foo = bar The region chr1:15-20 has foo = baz The region chr1:30-35 has foo = boo The region chr1:0-25 has foo = boz There are some important caveats with using this feature:you should ensure the properties assigned don't clash with native property names. In such cases, which property is accessed may be ambiguous. some operations on Regions objects that modify the regions will lose the metadata because they return new Regions objects. If you want to re-associate the metadata you may have to do this manually (for example, by using findOverlapRegions or similar.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/loading-and-saving#loading-bed-files</url>
    <fullTitle>Groovy NGS: Loading And Saving, Loading BED files [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>Regions are commonly loaded from and saved to BED files. Groovy NGS provides the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/BED.html BED class to read data from BED formatted files.The BED class is designed to work with both in-memory BED files and also provide a subset of operations that can work in streaming fashion with files on storage. Therefore its constructor accepts a file path but will not load the contents automatically. To load a Regions object into memory from a BED file, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/BED.html#load(java.util.Map) load method. Consider this bed file: text chr1 100 150 r1 chr2 190 250 r2 chr3 300 350 r3 Then we can load it to a regions object with: groovy bed = new BED("test.bed").load() assert bed.numberOfRanges == 3 This will load a minimalist version of the BED that does not include the fourth column (usually referred to as the name or id column in the BED file). This is designed to minimise memory use and the resultant Regions object does not support the assignment of additional properties. To load a fully functional Regions object, add the full:true optional parameter in either the constructor or the load function: groovy bed = new BED("test.bed", full:true).load() assert bed.numberOfRanges == 3 assert bed[0].id == "r1"</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/loading-and-saving#saving-bed-files</url>
    <fullTitle>Groovy NGS: Loading And Saving, Saving BED files [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>To save data in BED format from a Regions object, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Regions.html#save(java.lang.String) Regions.save method on the Regions object.By default, this will save the regions in the order they were loaded, without any additional columns. To add the id / name column as the fourth column, specify a closure that returns the value to store there using the extra attribute. For example, to save the above BED file with the same contents to a new file name, you would use: groovy bed.save('test2.bed', extra: { it.id }) It's common to want to save regions in sorted order (eg: so that the file can be indexed). To do this, supply the sorted attribute. If you supply the value true then the file will be written in sorted order using lexical sorting on the contig/chromosome name. This means that chr10 will follow directly after chr1 . You can sort in a custom order by setting the sorted attribute to your own implementation of a Comparator&lt;Region> .If you would like to store chromosomes in genomic order (ie: chr2 follows chr1 ), Groovy NGS provides the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/NumericRegionComparator.html NumericRegionComparator class that you can use. For example: groovy bed.save('test2.bed', extra: { it.id }, sorted: new NumericRegionComparator())</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-2-genomic-regions/loading-and-saving#region-based-data-tables</url>
    <fullTitle>Groovy NGS: Loading And Saving, Region Based Data Tables [Chapter 2 Genomic Regions]</fullTitle>
    <text>
      <text>It is common to encounter files stored in column based format (for example, tab separated) with genomic coordinates in some of the columns and other data in the remaining columns.To load this kind of data, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/RangedData.html RangedData class. This class expects a tab or comma separated file with headers defining the column names. The class will auto-detect data types for columns based on the contents of the first rows (numeric columns being parsed as numbers). By default the first 3 columns are interpreted as the contig / chromosome, start coordinate and end coordinate repsectively. However you can change this by providing the column indices for these in the constructor.Consider the following file: text chr start end name age chr1 100 120 simon 10 chr1 140 210 fred 15 chr1 190 250 jane 20 chr1 300 350 tom 13 We can load a Regions object with name and age populated as follows: regions = new RangedData("test.tsv").load() assert r[0].name == "simon" assert r[0].age == 10 For more details, see the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/RangedData.html RangedData class API documentation.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/parsing-vcf-files#loading-a-vcf-file</url>
    <fullTitle>Groovy NGS: Parsing Vcf Files, Loading a VCF File [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>Groovy NGS provides a dedicated VCF parser designed to offer highly streamlined access to VCF information, via the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/VCF.html gngs.VCF class. This parser allows access to key header properties as well as full information about variants.To load a VCF into memory, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/VCF.html#parse(Closure) VCF.parse static method. This method accepts a closure which, if provided, is called for each variant to determine if the variant should be retained. This allows loading a subset of variants from a VCF. For example, here we load only variants on chromosome 22. Input groovy vcf = VCF.parse("test.vcf") { it.chr == 'chr22' } println "The samples are: $vcf.samples" println "There are ${vcf.size()} variants on chr22" Output text The samples are: [NA12877, NA12878, NA12879] There are 24 variants on chr22</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/parsing-vcf-files#accessing-header-information-only</url>
    <fullTitle>Groovy NGS: Parsing Vcf Files, Accessing Header Information Only [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>If access to the variant information is not required, you can avoid parsing the whole VCF by calling the constructor directly: Input groovy vcf = new VCF("test.vcf") println "The samples are: $vcf.samples" Output text The samples are: [NA12877, NA12878, NA12879]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/parsing-vcf-files#streaming-processing</url>
    <fullTitle>Groovy NGS: Parsing Vcf Files, Streaming Processing [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>For large VCFs it can be beneficial to process a VCF file line by line. In this case, the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/VCF.html#filter(java.lang.String,%20Closure) VCF.filter method can be used to process variants in streaming fashion. By default, the filter method reads from standard input and writes to standard output, but a file names can be provided to read from a file. groovy VCF.filter('test.vcf') { it.chr == 'chr22' // output only variants on chr22 to stdout }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/parsing-vcf-files#processing-variants-in-vcfs</url>
    <fullTitle>Groovy NGS: Parsing Vcf Files, Processing Variants in VCFs [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>Each variant is represented by an instance of the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Variant.html gngs.Variant class which makes available detailed information about the variant. The VCF class implements the Iterable&lt;Variant> interface, making available standard operations that are available on all Groovy https://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Iterator.html Iterators. Input groovy vcf = VCF.parse("test.vcf").countBy { it.type } Output text {SNP=22, DEL=1, INS=1}</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/parsing-vcf-files#indexed-vcfs</url>
    <fullTitle>Groovy NGS: Parsing Vcf Files, Indexed VCFs [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>When accessing a small number of variants from a large VCF, it is more efficient to index the VCF and parse only the relevant lines. The https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/VCFIndex.html gngs.VCFIndex class can be used to query variants within a specified genomic region. Input groovy index = new VCFIndex("test.vcf.gz") index.iterator("chr1", 13792200, 13792300).collect { it } Output text [chr1:13792284 G/T]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/working-with-variants#general-notes</url>
    <fullTitle>Groovy NGS: Working With Variants, General Notes [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>Variants are one of the core focuses of many genomic analysis, so Groovy NGS goes to significant effort to streamline and optimise access to variant information. This is one of the exceptions where, even though HTSJDK does provide a https://samtools.github.io/htsjdk/javadoc/htsjdk/htsjdk/variant/variantcontext/VariantContext.html VariantContext class, Groovy NGS provides a different, substitute class as a complementary option. This is because HTSJDK focuses on completely representing all features from the VCF specification and also ensuring high levels of safety and robustness in how it is used. Groovy NGS, therefore, provides an alternative that is highly ergonomic, but makes some important simplifiying assumptions and only presents a commonly used subset of the VCF specification.The most important simplifying assumption is that many operations, there is a "simple" version that returns results for the first allele and / or the first sample in a VCF. This assumption means that many analyses where these assumptions hold true can be expressed with vastly simpler code and especially for interactive analyses (such as in Jupyter Notebooks), this adds a great level of convenience.Warning: you may miss variants when using default methods with multi-allelic variants. In general, you should apply Groovy NGS classes to VCFs that have been "normalised" and reduced to primitives, for example, by using https://samtools.github.io/bcftools/bcftools.html#norm bcftools norm.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/working-with-variants#variant-properties</url>
    <fullTitle>Groovy NGS: Working With Variants, Variant Properties [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>The key class for working with variants in Groovy NGS is the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Variant.html Variant class. Conceptually, this class represents a single line in a VCF file, and hence it can include multiple alleles and multiple samples at a single site. Alleles The base sequence of default alternate allele is accessible as the alt property. This value is exactly as presented in the first element of the ALT column from the VCF file. Therefore, for indels it includes the context base that is generally present for those variant types. The full list of alternate allele bases is accessible via the alts property.These properties tell you only the base sequence of the allele. For more information, you can access a full list of Allele objects as the alleles property. These allow you to directly query the type of the variant, start and end position and other attributes. Dosage GNGS refers to the number of copies of a variant that are present as the dosage . Therefore, in a diploid genome, having genotype 1/1 will yield a dosage of 2 for the alternate allele, while having genotype 1/0 will give dosage of 1. This generally makes calculations more straightforward than dealing with the exact genotype, especially when accessing the dosage for the first sample and allele (directly as the dosage property).To see the dosage of the default allele for every sample, you can query the dosages property. For example assuming the proband is the first sample in a trio VCF, we can identify de novo variants as follows: groovy vcf.grep { it.dosages[0] > 0 &amp;&amp; it.dosages[1]==0 &amp;&amp; it.dosages[2] == 0 } Depth The total read depth at the site of a variant can be queried using the totalDepth property. To get the depth of the first allele, you may query the altDepth property. To see the alternate allele depths for other alleles, you can call getAlleleDepths(alleleIndex) where providing 0 specifies the reference allele.Often we are interested in the proportion of reads supporting a variant (refererred to as the variant allele frequency . This is returned as the vaf property for the default allele and sample. To query it for arbitrary alelel and sample, call the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Variant.html#getVaf(int,%20int) getVaf(alleleIndex, sampleIndex) method.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/working-with-variants#variants-as-regions</url>
    <fullTitle>Groovy NGS: Working With Variants, Variants as Regions [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>Like other entities that belong to a specific location in the genome, Variants implement the IRegion interface which allows variants to be passed to many functions for region based operations as a parameter.For example, to test if a particular variant lies within a region of interest: Input groovy roi = new Region("chr22:16591390-16591800") println("Does variant $v overlap $roi? : " + roi.overlaps(v)) Output text Does variant chr22:16591593 A/G overlap chr22:16591390-16591800? : true</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/working-with-variants#querying-vcfs-for-presence-of-variants</url>
    <fullTitle>Groovy NGS: Working With Variants, Querying VCFs for Presence of Variants [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>Finding out whether a particular variant is contained in a VCF is easy because the VCF class implements the Groovy https://groovy-lang.org/operators.html#_membership_operator membership operator which enables use of the in keyword. Hence we can query if a VCF contains a particular variant by using code such as: groovy vcf = VCF.parse('test.vcf') variant = vcf[0] if(variant in vcf) println "Variant $variant is in the VCF!" Note: in testing whether a variant is "in" a VCF, the position and allele are compared. However, the dosage (zygosity) are not compared. Therefore, querying if a homozygous variant is present in a VCF that contains the VCF in heterozygous form will return true . In fact, even if the variant is present but genotyped as homozygous reference, the query will return true . To ascertain whether any sample has non-zero dosage for the variant, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/VCF.html#find(gngs.Variant) find to retrieve the variant and then directly query the dosages. For example: vcf.find(v).dosages.any { it > 0 } Warning: this function may behave in unexpected ways when multi-allelic variants are used as query or target VCF. The find and in functions will match a variant in a VCF if any allele matches any allele in the query.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/working-with-variants#info-fields</url>
    <fullTitle>Groovy NGS: Working With Variants, Info Fields [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>Info fields for each https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Variant.html Variant are parsed and accessible as a Map keyed on the name. Values are represented as String s and are not further parsed into typed entities matching the INFO fields declared in the VCF header.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/working-with-variants#annotated-variants</url>
    <fullTitle>Groovy NGS: Working With Variants, Annotated Variants [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>The https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Variant.html Variant class has built in support for parsing https://asia.ensembl.org/info/docs/tools/vep/index.html VEP annotations. These are accessed via the vepInfo property. As VEP can create multiple annotations, the result is returned as a List , each entry which is a Map&lt;String,Object> of VEP annotations.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-3-vcf-files/working-with-variants#updating-variant-attributes</url>
    <fullTitle>Groovy NGS: Working With Variants, Updating Variant Attributes [Chapter 3 Vcf Files]</fullTitle>
    <text>
      <text>GNGS contains limited support for updating variants, allowing a variant that has been read from a VCF file to be modified and then written out with the changes intact. Due to how Variant entries are stored, it is critical that when updating a variant the update is performed within a update closure: groovy v.update { v.info.MYINFO = "a new INFO property" } When updated this way, changes to INFO and genotype fields will be written out if made as part of a filter operation or the VCF is written using the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/VCF.html#print(java.lang.Appendable) print method.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-4-alignment-files/opening-and-reading-alignment-files#introduction</url>
    <fullTitle>Groovy NGS: Opening And Reading Alignment Files, Introduction [Chapter 4 Alignment Files]</fullTitle>
    <text>
      <text>Sequence alignments are central to working with genomic data. Groovy NGS supplies a wrapper class that adds idiomatic Groovy constructs to the underlying HTSJDK and Picard classes that provide Java support for working with genomic data. Unlike the support for genomic regions, this layer is a relatively thin wrapper since HTSJDK already provides a very effective API.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-4-alignment-files/opening-and-reading-alignment-files#opening-bam-and-cram-files</url>
    <fullTitle>Groovy NGS: Opening And Reading Alignment Files, Opening BAM and CRAM Files [Chapter 4 Alignment Files]</fullTitle>
    <text>
      <text>The core class for interacting with alignment files is the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/SAM.html SAM class. This class only works with indexed BAM, CRAM or SAM files. It provides a wealth of functions that allow highly efficient, streamlined access to reads within these formats.To create a SAM object, just use the constructor: groovy bam = new SAM("test.bam") To see which contigs are in the file, you can access the contigs property: Input groovy bam.contigs Output text chrM=16571 chr1=249250621 chr2=243199373 chr3=198022430 ... To see which samples are in an alignment file, use the samples property: Input groovy bam.samples Output text [NA12878, NA12878] Note that each sample may be returned multiple times if there is more than one read group for the sample in the alignment file.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-4-alignment-files/opening-and-reading-alignment-files#accessing-reads</url>
    <fullTitle>Groovy NGS: Opening And Reading Alignment Files, Accessing Reads [Chapter 4 Alignment Files]</fullTitle>
    <text>
      <text>Reads within the SAM file are accessed using several different methods. The right method depends onwhether you want to access reads from a specific region if you need access to both pairs of paired end reads at the same time For basic access, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/SAM.html#eachRecord(java.util.Map,%20groovy.lang.Closure) eachRecord method to iterate over every read in the SAM file, one at a time: Input groovy count = 0 bam.eachRecord { ++count } println "There are $count reads in the file" Output text There are 1899 reads in the file Within the closure, a https://www.javadoc.io/doc/com.github.samtools/htsjdk/1.133/htsjdk/samtools/SAMRecord.html SAMRecord object is passed as an argument and all of its properties are accessible.For example, the maximum insert size could be calculated using the inferredInsertSize property of each SAMRecord object: Input groovy maxInsertSize = 0 bam.eachRecord { r -> maxInsertSize = Math.max(maxInsertSize, Math.abs(r.inferredInsertSize)) } println "The maximum insert size is $maxInsertSize" Output text The maximum insert size is 114074 While eachRecord is a simple method, often a more idiomatic and functional style is achievable by using the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/SAM.html#withIterator(groovy.lang.Closure) withIterator which makes available a Groovy https://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Iterator.html Iterator, affording all of the usual Groovy enhancements that are available on iterator objects.For example, the same can be achieved with an iterator like so: Input groovy bam.withIterator { it*.inferredInsertSize.max() } Output text 114074 Accessing reads from a specific locus To access reads from a given locus, you can supply a Region object as a parameter to the withIterator or eachRecord methods to specify the region.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-4-alignment-files/opening-and-reading-alignment-files#accessing-paired-reads</url>
    <fullTitle>Groovy NGS: Opening And Reading Alignment Files, Accessing Paired Reads [Chapter 4 Alignment Files]</fullTitle>
    <text>
      <text>It is often useful to access reads in their pairs. However, within coordinate sorted alignment files, paired reads may be spaced far apart which makes retrieval of the mate for each read potentially very expensive. Groovy NGS offers an optimised method, https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/SAM.html#eachPair(groovy.lang.Closure) eachPair. Input groovy count = 0 bam.eachPair { r1, r2 -> ++count} println "There are $count read pairs" Output text There are 942 read pairs Note: accessing read pairs can be memory intensive, as each read is buffered until its mate is found. Unpaired reads will not be output.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-4-alignment-files/opening-and-reading-alignment-files#generating-pileups</url>
    <fullTitle>Groovy NGS: Opening And Reading Alignment Files, Generating Pileups [Chapter 4 Alignment Files]</fullTitle>
    <text>
      <text>Genomic data often contains many reads covering any one position and it is of interest to access the full set of reads covering the position (known as a "pileup"). Groovy NGS offers several methods on the SAM class as well as a dedicated https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Pileup.html Pileup class to make generating pileups easier. Pileup at a Specific Position To generate a pileup at a specific position, use the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/SAM.html#pileup(java.lang.String,%20int) pileup method. This returns a Pileup object that can then be queried for summary information as well as the full list of reads covering the position: Input groovy p = bam.pileup('chr1',16890560) println "There are ${p.alignments*.read.size()} reads at the position" println "There are ${p.summaryAsMap.C} C bases at the position" Output text There are 3 reads at the position There are 3 C bases at the position From this we can see there are 3 reads which all have the base C at that position. Pileups at Multiple Positions Generating a pileup at a single position is very compute intensive as it requires fully scanning the context around the position to find all the reads. If you are analysing a whole region, you should instead create a PileupIterator over the whole region using the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/SAM.html#pileup(java.lang.String,%20int,%20int) pileup(chr,start,end) method. This will return an iterator that you can apply standard Groovy methods to enumerate the pileup state efficiently at each position within the range. Input groovy bam.pileup('chr1',16890550, 16890560 ).collect { p -> p.alignments.size() } Output text [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-4-alignment-files/opening-and-reading-alignment-files#calculating-coverage-depth</url>
    <fullTitle>Groovy NGS: Opening And Reading Alignment Files, Calculating Coverage Depth [Chapter 4 Alignment Files]</fullTitle>
    <text>
      <text>As seen above, coverage can be calculated using the pileup method on the SAM class. There are several direct methods for calculating coverage depth which are more efficient, however, including some that directly compute statistics for you: Input groovy bam.coverageStatistics('chr1',16890550, 16890560 ).mean Output text 2.090909090909091 Note that the object returned is an Apache commons-math https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/stat/descriptive/SummaryStatistics.html SummaryStatistics object, allowing you to access any of its properties.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-5-plotting/plotting#basic-form-of-plots</url>
    <fullTitle>Groovy NGS: Plotting, Basic Form of Plots [Chapter 5 Plotting]</fullTitle>
    <text>
      <text>Visualisation of data is an extremely common task in working with genomic data. Unfortunately, the libraries available for generating plots in Java are mostly geared towards applications and are not as easy to use or feature rich for use with scientific data.To ease plot generation, Groovy NGS includes the https://github.com/eseifert/gral Gral plotting library to support generation of plots by default, allowing any APIs from this library to be called to create visualisations. As with many Java based plotting APIs however, it is not well integrated with data types typically used in data analysis, requiring many API calls to generate a simple plot. Groovy NGS therefore includes a set of wrappers that make generation of useful plots directly from raw data very ergonomic. These APIs are based around the plotting libraries supported in the https://github.com/twosigma/beakerx BeakerX JupyterLab Extenions, allowing the same plots that are generated in notebooks to then be easily used offline in command line applications.Plots are created by creating a Plot object: groovy import gngs.plot.* p = new Plot() Most attributes of the plots are passed using Groovy's https://docs.groovy-lang.org/latest/html/documentation/#_named_parameters Map Constructor idiom, such that plot-level features are mostly configured in the constructor by passing them as attributes. An example of a plot with title, axis labels and X and Y ranges set for the plot area is as follows: groovy p = new Plot( title: 'An example plot', xLabel: 'This is the x axis', yLabel: 'This is the y axis', xBound: [0, 10], yBound: [0, 30] )</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-5-plotting/plotting#saving-plots</url>
    <fullTitle>Groovy NGS: Plotting, Saving Plots [Chapter 5 Plotting]</fullTitle>
    <text>
      <text>Once you have created a plot, you will likely want to save it to a file.This can easily be achieved by calling the save function: groovy p.save('example_plot.png') By default, images are saved resolution of 1024 x 800, but you can set this explicitly by passing width and height properties: groovy p.save('example_plot.png', width: 1600, height: 1200) At this stage, these will save an empty plot, because we have not added any data to it.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-5-plotting/plotting#adding-data-to-plots</url>
    <fullTitle>Groovy NGS: Plotting, Adding Data to Plots [Chapter 5 Plotting]</fullTitle>
    <text>
      <text>Data is added to plots by creating data objects and using Groovy's &lt;&lt; operator on the plot object. The data objects themselves are created using the same map-constructor style syntax, and can be Line , Bars , Points , or Area objects: groovy p &lt;&lt; new Line( x: [1,2,3,4,5], y: [1,4,9,16,25] ) Note that in most of these data objects, the actual position of the data points is expressed as x and y attributes of the objects.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-5-plotting/plotting#specifying-colors</url>
    <fullTitle>Groovy NGS: Plotting, Specifying Colors [Chapter 5 Plotting]</fullTitle>
    <text>
      <text>Further attributes can be specified such as the color of the objects. The color can be specified as https://docs.oracle.com/javase%2F7%2Fdocs%2Fapi%2F%2F/java/awt/Color.html java.awt.Color objects, for which the built in predefined colors are often useful: groovy import java.awt.Color p &lt;&lt; new Line( x: [1,2,3,4,5], y: [1,4,9,16,25], color: Color.red ) p &lt;&lt; new Line( x: [1,2,3,4,5], y: [1,8,27,64,125], color: Color.blue )</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-5-plotting/plotting#adding-legends</url>
    <fullTitle>Groovy NGS: Plotting, Adding Legends [Chapter 5 Plotting]</fullTitle>
    <text>
      <text>To add a legend to the plot, specify the displayName attribute on each data object to be drawn: groovy import java.awt.Color p &lt;&lt; new Line( x: [1,2,3,4,5], y: [1,4,9,16,25], color: Color.red, displayName: 'Square of Numbers' ) p &lt;&lt; new Line( x: [1,2,3,4,5], y: [1,8,27,64,125], color: Color.blue, displayName: 'Cube of Numbers' )</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-5-plotting/plotting#distribution-plots</url>
    <fullTitle>Groovy NGS: Plotting, Distribution Plots [Chapter 5 Plotting]</fullTitle>
    <text>
      <text>As they are very common to show overall data properties, Groovy NGS supports two kinds of distribution plots that are especially easy to create: Density plots and Histograms. groovy p = new Plot(title: 'Guassian Distribution') p &lt;&lt; new gngs.plot.bx.Density.Area( data: (1..100).collect { 5 + r.nextGaussian() } ) groovy h = new Histogram( title: "Gaussian Distribution", data: (1..500).collect { 5 + r.nextGaussian() } )</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-5-plotting/plotting#accessing-generated-images</url>
    <fullTitle>Groovy NGS: Plotting, Accessing Generated Images [Chapter 5 Plotting]</fullTitle>
    <text>
      <text>If you want to add more to the generated plots or manipulate the image in additional ways, you can generate the https://docs.oracle.com/javase/8/docs/api/java/awt/image/BufferedImage.html BufferedImage directly and use standard Java features to draw on it: groovy BufferedImage image = p.image Graphics2D imageGraphics = image.createGraphics() imageGraphics.drawRect(10,10, 20,20) ... As with saving the plot, you can specify the resolution: groovy BufferedImage image = p.getImage(1600, 1200) ...</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-6-miscellaneous-utilities/miscellaneous-utilities#creating-readers-writers-and-streams</url>
    <fullTitle>Groovy NGS: Miscellaneous Utilities, Creating Readers, Writers and Streams [Chapter 6 Miscellaneous Utilities]</fullTitle>
    <text>
      <text>It is very common to encounter files that are compressed in various different formats and often an annoyance to have to invoke dedicated APIs and libraries to read them depending on what exact format the user supplied.Groovy NGS supports a concept of a "file like" object that can represent a file in many different forms, from a File object, input stream object, or a plain path, all of which can be compressed with gzip or bgzip or uncompressed. Many of the classes in Groovy NGS will take an untyped "file like" argument which will be auto-detected to use the right process to create a Reader or Writer to handle the file.You can support similar functionality by calling the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Utils.html#reader(def,%20Closure) Utils.reader and https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/Utils.html#writer(java.lang.String) Utils.writer methods.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-6-miscellaneous-utilities/miscellaneous-utilities#formatting-tables</url>
    <fullTitle>Groovy NGS: Miscellaneous Utilities, Formatting Tables [Chapter 6 Miscellaneous Utilities]</fullTitle>
    <text>
      <text>Markdown has become a de facto standard for writing documentation and reports. One of the more tedious aspects is formatting Markdown tables. Groovy NGS supplies a highly flexible function to format data in lists as tables. See Input groovy def data = [ [1,2,3], [4,5,6] ] Utils.table(['a','b','c'], data) Output text a | b | c --|---|-- 1 | 2 | 3 4 | 5 | 6</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-6-miscellaneous-utilities/miscellaneous-utilities#jupyterlab-support</url>
    <fullTitle>Groovy NGS: Miscellaneous Utilities, JupyterLab Support [Chapter 6 Miscellaneous Utilities]</fullTitle>
    <text>
      <text>Groovy NGS makes an excellent addition to using Groovy within a Jupyter Notebook (or JupyterLab).You can use any available Groovy kernel, however a particularly useful one is https://github.com/twosigma/beakerx BeakerX which provides Groovy kernels out of the box along with a range of Jupyter widgets as enhancements. Together with Groovy NGS. this makes a very effective data analysis platform for genomic data.To further support use within BeakerX, Groovy NGS provides some additional plots. These extend the existing BeakerX plots to provide distrubtion plots (based on kernel density estimates).The example below shows how the Groovy NGS density plot is displayed within a Jupyter Notebook. Input groovy r = new Random() data = (1..1000).collect { r.nextGaussian() } new Plot(title: "Gaussian Distribution") &lt;&lt; \ new Density.Area(data:data) Output null guassian_distribution.png image</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/groovy-ngs-utils/userguide/chapter-6-miscellaneous-utilities/miscellaneous-utilities#refgene-database-access</url>
    <fullTitle>Groovy NGS: Miscellaneous Utilities, RefGene Database Access [Chapter 6 Miscellaneous Utilities]</fullTitle>
    <text>
      <text>An enormous amount of work in human genomics requires gene definitions. Groovy NGS provides support for loading and querying the UCSC RefGene database directly to enable access to gene and transcript definitions.The following example shows how to create the https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/RefGenes.html RefGenes class and query gene information from it: Input groovy refgene = new RefGenes('refGene.txt.gz') refgene.getExons('DVL1') Output text 15 regions starting at chr1:1336142-1336516 The https://ssadedin.github.io/groovy-ngs-utils/doc/gngs/RefGenes.html RefGenes class provides a wealth of methods for querying gene information.Note: Support for Gencode is available in the gngs.gencode package. This support is functional but still under development and less tested than the RefGene support.</text>
      <score>STANDARD</score>
    </text>
  </entry>
</znai>
